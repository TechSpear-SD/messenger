# Guide d'impl√©mentation - Messenger

Ce guide d√©taille comment √©tendre et d√©velopper dans le syst√®me Messenger. Il couvre l'ajout de nouveaux composants et les patterns d'architecture utilis√©s.

## üèóÔ∏è Patterns d'architecture

### 1. Singleton Pattern - MessengerApp

L'application principale utilise le pattern Singleton pour garantir une seule instance :

```typescript
export class MessengerApp {
    private static instance: MessengerApp;

    public static getInstance(): MessengerApp {
        if (!MessengerApp.instance) {
            MessengerApp.instance = new MessengerApp();
        }
        return MessengerApp.instance;
    }
}
```

### 2. Factory Pattern - Providers et Workers

Les providers et workers utilisent le Factory pattern pour l'instanciation :

```typescript
export class ProviderFactory {
    static create(config: ProviderConfig): AbstractProvider {
        const providers: AbstractProvider[] = [new MockProvider()];
        const found = providers.find((p) => p.id === config.providerId);
        if (!found) {
            throw new Error(`Unknown provider: ${config.providerId}`);
        }
        return found;
    }
}
```

### 3. Observer Pattern - Event Bus

Communication d√©coupl√©e via un syst√®me d'√©v√©nements typ√© :

```typescript
type EventPayloads = {
    [EventNames.TemplateBeforeExecute]: { templateId: string; data: any };
    [EventNames.ProviderAfterSend]: { providerId: string; response: any };
};

bus.emit(EventNames.TemplateBeforeExecute, { templateId, data });
```

### 4. Strategy Pattern - Providers

Diff√©rentes strat√©gies d'envoi encapsul√©es dans des providers :

```typescript
abstract class AbstractProvider {
    abstract readonly supportedChannels: SupportedChannel[];

    protected abstract sendByChannel(
        channel: SupportedChannel,
        message: ProviderExecutionContext,
    ): Promise<string | undefined>;
}
```

### 5. Template Method Pattern - BaseWorker

Structure commune avec points d'extension :

```typescript
abstract class BaseWorker {
    async handleMessage(message: QueueMessage): Promise<void> {
        // Logic commune
        await this.processMessage(message); // Hook pour classes d√©riv√©es
    }

    protected abstract processMessage(message: QueueMessage): Promise<void>;
}
```

## üîß Ajout de nouveaux composants

### 1. Ajouter un nouveau Provider

#### √âtape 1 : Cr√©er la classe Provider

```typescript
// src/providers/email/sendgrid-provider.ts
import { AbstractProvider } from './provider.interface';
import { SupportedChannel } from '../../config';
import { ProviderExecutionContext } from '../../core/entities/provider-execution-ctx';

export class SendGridProvider extends AbstractProvider {
    readonly id = 'sendgrid-provider';
    readonly supportedChannels: SupportedChannel[] = ['email'];

    protected async sendByChannel(
        channel: SupportedChannel,
        message: ProviderExecutionContext,
    ): Promise<string | undefined> {
        switch (channel) {
            case 'email':
                return await this.sendEmail(message);
            default:
                throw new Error(`Unsupported channel: ${channel}`);
        }
    }

    private async sendEmail(
        message: ProviderExecutionContext,
    ): Promise<string> {
        // Impl√©mentation SendGrid
        const sgMail = require('@sendgrid/mail');
        sgMail.setApiKey(process.env.SENDGRID_API_KEY);

        const msg = {
            to: message.to,
            from: 'noreply@example.com',
            subject: message.subject,
            html: message.body,
        };

        const response = await sgMail.send(msg);
        return response[0].headers['x-message-id'];
    }
}
```

#### √âtape 2 : Enregistrer dans la Factory

```typescript
// src/providers/provider-factory.ts
import { SendGridProvider } from './email/sendgrid-provider';

export class ProviderFactory {
    static create(config: ProviderConfig): AbstractProvider {
        const providers: AbstractProvider[] = [
            new MockProvider(),
            new SendGridProvider(), // Nouveau provider
        ];
        // ...
    }
}
```

#### √âtape 3 : Ajouter la configuration

```typescript
// src/config/providers.ts
export const providersConfig: ProviderConfig[] = [
    {
        providerId: 'sendgrid-provider',
        name: 'SendGrid',
        description: 'SendGrid email provider',
    },
];
```

### 2. Ajouter un nouveau Worker

#### √âtape 1 : Cr√©er la classe Worker

```typescript
// src/workers/webhook-worker.ts
import { BaseWorker } from './base-worker';
import { QueueMessage } from '../core/entities/queue-message';
import { WorkerConfig } from '../config';

export class WebhookWorker extends BaseWorker {
    readonly id = 'webhook-worker';
    readonly workerConfig: WorkerConfig;

    constructor(workerConfig: WorkerConfig) {
        super();
        this.workerConfig = workerConfig;
    }

    protected async handleConnect(): Promise<void> {
        // Initialisation des connexions webhook
    }

    protected async handleSubscribe(): Promise<void> {
        // Souscription aux webhooks
    }

    protected async handleDisconnect(): Promise<void> {
        // Nettoyage des connexions
    }

    protected async processMessage(message: QueueMessage): Promise<void> {
        // Traitement sp√©cifique aux webhooks
        await this.sendWebhook(message);
    }

    private async sendWebhook(message: QueueMessage): Promise<void> {
        // Impl√©mentation webhook
    }
}
```

#### √âtape 2 : Enregistrer dans la Factory

```typescript
// src/workers/worker-factory.ts
import { WebhookWorker } from './webhook-worker';

export class WorkerFactory {
    static create(config: WorkerConfig): BaseWorker {
        const workers: BaseWorker[] = [
            new GenericBullWorker(config),
            new WebhookWorker(config), // Nouveau worker
        ];
        // ...
    }
}
```

### 3. Ajouter un nouveau Plugin

#### √âtape 1 : Cr√©er la classe Plugin

```typescript
// src/core/plugins/metrics-plugin.ts
import { Plugin } from './plugin';
import { EventNames } from '../bus/event-names';

export class MetricsPlugin extends Plugin {
    private metrics = new Map<string, number>();

    registerListeners(): void {
        this.bus.on(EventNames.TemplateAfterExecute, (payload) => {
            this.incrementCounter(`template.${payload.templateId}.executed`);
        });

        this.bus.on(EventNames.ProviderAfterSend, (payload) => {
            this.incrementCounter(`provider.${payload.providerId}.sent`);
        });
    }

    private incrementCounter(key: string): void {
        const current = this.metrics.get(key) || 0;
        this.metrics.set(key, current + 1);
        this.getContextLogger().info(`Metric: ${key} = ${current + 1}`);
    }

    getMetrics(): Record<string, number> {
        return Object.fromEntries(this.metrics);
    }
}
```

#### √âtape 2 : Enregistrer dans l'application

```typescript
// src/app.ts
import { MetricsPlugin } from './core/plugins/metrics-plugin';

export class MessengerApp {
    private registerPlugins() {
        this.pluginManager.register(LoggerPlugin);
        this.pluginManager.register(MetricsPlugin); // Nouveau plugin
    }
}
```

### 4. Ajouter une nouvelle transformation de donn√©es

#### √âtape 1 : Cr√©er le fichier de transformation

```typescript
// transforms/user-enrichment.ts
import { DataTransform } from '../src/transforms/transform.type';

const userEnrichment: DataTransform = async (data: any) => {
    return {
        ...data,
        // Enrichissement des donn√©es utilisateur
        fullName: `${data.firstName} ${data.lastName}`,
        registrationDate: new Date(data.createdAt).toLocaleDateString('fr-FR'),
        isNewUser: isUserNew(data.createdAt),
        // Ajout d'URLs dynamiques
        dashboardUrl: `${process.env.APP_URL}/dashboard?user=${data.userId}`,
        unsubscribeUrl: `${process.env.APP_URL}/unsubscribe?token=${data.unsubscribeToken}`,
    };
};

function isUserNew(createdAt: string): boolean {
    const created = new Date(createdAt);
    const now = new Date();
    const diffDays = (now.getTime() - created.getTime()) / (1000 * 3600 * 24);
    return diffDays <= 7; // Nouveau si inscrit il y a moins de 7 jours
}

export default userEnrichment;
```

#### √âtape 2 : R√©f√©rencer dans la configuration du template

```typescript
// src/config/templates.ts
export const templatesConfig: TemplateConfig[] = [
    {
        templateId: 'user_welcome_enriched',
        providerId: 'sendgrid-provider',
        path: 'user_welcome',
        channels: ['email'],
        dataTransformFiles: ['user-enrichment.ts'], // Nouvelle transformation
    },
];
```

### 5. Cr√©er un nouveau template

#### √âtape 1 : Cr√©er les fichiers template

```handlebars
<!-- templates/order_confirmation/subject.hbs -->
{{#if orderNumber}}
    Confirmation de commande #{{orderNumber}}
{{else}}
    Confirmation de votre commande
{{/if}}
```

```handlebars
<!-- templates/order_confirmation/body.hbs -->
<div style='font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;'>
    <h1>Merci pour votre commande !</h1>

    {{#if customerName}}
        <p>Bonjour {{customerName}},</p>
    {{else}}
        <p>Bonjour,</p>
    {{/if}}

    <p>Nous avons bien re√ßu votre commande
        {{#if orderNumber}}#{{orderNumber}}{{/if}}
        du
        {{formatDate orderDate}}.</p>

    <h2>D√©tails de la commande</h2>
    <table style='width: 100%; border-collapse: collapse;'>
        <thead>
            <tr style='background-color: #f5f5f5;'>
                <th style='padding: 10px; text-align: left;'>Produit</th>
                <th style='padding: 10px; text-align: right;'>Quantit√©</th>
                <th style='padding: 10px; text-align: right;'>Prix</th>
            </tr>
        </thead>
        <tbody>
            {{#each items}}
                <tr>
                    <td
                        style='padding: 10px; border-bottom: 1px solid #eee;'
                    >{{name}}</td>
                    <td
                        style='padding: 10px; border-bottom: 1px solid #eee; text-align: right;'
                    >{{quantity}}</td>
                    <td
                        style='padding: 10px; border-bottom: 1px solid #eee; text-align: right;'
                    >{{price}}‚Ç¨</td>
                </tr>
            {{/each}}
        </tbody>
        <tfoot>
            <tr style='font-weight: bold; background-color: #f9f9f9;'>
                <td colspan='2' style='padding: 10px; text-align: right;'>Total
                    :</td>
                <td
                    style='padding: 10px; text-align: right;'
                >{{totalAmount}}‚Ç¨</td>
            </tr>
        </tfoot>
    </table>

    {{#if trackingNumber}}
        <p style='margin-top: 20px;'>
            <strong>Num√©ro de suivi :</strong>
            {{trackingNumber}}<br />
            <a href='{{trackingUrl}}' style='color: #007cba;'>Suivre votre colis</a>
        </p>
    {{/if}}

    <p style='margin-top: 30px; color: #666; font-size: 14px;'>
        Si vous avez des questions, contactez-nous √†
        <a href='mailto:{{supportEmail}}'>{{supportEmail}}</a>
    </p>
</div>
```

#### √âtape 2 : Cr√©er la transformation pour formater les donn√©es

```typescript
// transforms/order-formatting.ts
const orderFormatting: DataTransform = async (data: any) => {
    return {
        ...data,
        // Formatage des dates
        orderDate: new Date(data.orderDate).toLocaleDateString('fr-FR'),
        // Calcul du total si pas fourni
        totalAmount:
            data.totalAmount ||
            data.items.reduce(
                (sum: number, item: any) => sum + item.quantity * item.price,
                0,
            ),
        // G√©n√©ration d'URL de tracking
        trackingUrl: data.trackingNumber
            ? `https://tracking.example.com/${data.trackingNumber}`
            : null,
    };
};

export default orderFormatting;
```

#### √âtape 3 : Configurer le template

```typescript
// src/config/templates.ts
export const templatesConfig: TemplateConfig[] = [
    // ... autres templates
    {
        templateId: 'order_confirmation',
        providerId: 'sendgrid-provider',
        path: 'order_confirmation',
        channels: ['email'],
        dataTransformFiles: ['order-formatting.ts'],
        description: 'Confirmation de commande avec d√©tails',
    },
];
```

#### √âtape 4 : Cr√©er le sc√©nario associ√©

```typescript
// src/config/scenarios.ts
export const scenariosConfig: ScenarioConfig[] = [
    // ... autres sc√©narios
    {
        scenarioId: 'order_placed',
        description: 'Commande pass√©e avec succ√®s',
        templateIds: ['order_confirmation'],
    },
];
```

## üîÑ Helpers Handlebars personnalis√©s

### Ajout de helpers globaux

```typescript
// src/core/services/template-renderer.ts
import Handlebars from 'handlebars';

// Enregistrement de helpers personnalis√©s
Handlebars.registerHelper('formatDate', function (date: string) {
    return new Date(date).toLocaleDateString('fr-FR');
});

Handlebars.registerHelper('formatCurrency', function (amount: number) {
    return new Intl.NumberFormat('fr-FR', {
        style: 'currency',
        currency: 'EUR',
    }).format(amount);
});

Handlebars.registerHelper('uppercase', function (str: string) {
    return str.toUpperCase();
});

Handlebars.registerHelper('eq', function (a: any, b: any) {
    return a === b;
});

Handlebars.registerHelper('gt', function (a: number, b: number) {
    return a > b;
});
```

### Utilisation dans les templates

```handlebars
{{! Utilisation des helpers personnalis√©s }}
<p>Date de commande : {{formatDate orderDate}}</p>
<p>Montant : {{formatCurrency totalAmount}}</p>
<p>Code : {{uppercase orderCode}}</p>

{{#if (gt itemCount 1)}}
    <p>Vous avez command√© {{itemCount}} articles.</p>
{{/if}}

{{#eq status 'confirmed'}}
    <div class='confirmed'>Commande confirm√©e !</div>
{{/eq}}
```

## üìä Monitoring et m√©triques

### Extension du syst√®me de m√©triques

```typescript
// src/core/plugins/advanced-metrics-plugin.ts
export class AdvancedMetricsPlugin extends Plugin {
    private startTimes = new Map<string, number>();

    registerListeners(): void {
        // Mesure de performance
        this.bus.on(EventNames.TemplateBeforeExecute, (payload) => {
            this.startTimes.set(payload.templateId, Date.now());
        });

        this.bus.on(EventNames.TemplateAfterExecute, (payload) => {
            const startTime = this.startTimes.get(payload.templateId);
            if (startTime) {
                const duration = Date.now() - startTime;
                this.recordMetric('template.execution.duration', duration, {
                    templateId: payload.templateId,
                });
                this.startTimes.delete(payload.templateId);
            }
        });

        // Comptage des erreurs
        this.bus.on(EventNames.TemplateError, (payload) => {
            this.incrementCounter('template.errors.total', {
                templateId: payload.templateId,
                error: payload.error.name,
            });
        });
    }

    private recordMetric(
        name: string,
        value: number,
        tags: Record<string, string>,
    ) {
        // Int√©gration avec Prometheus, DataDog, etc.
        this.getContextLogger().info(`Metric: ${name}`, { value, tags });
    }
}
```

## üß™ Tests et validation

### Tests unitaires pour providers

```typescript
// tests/providers/sendgrid-provider.test.ts
import { SendGridProvider } from '../../src/providers/email/sendgrid-provider';

describe('SendGridProvider', () => {
    let provider: SendGridProvider;

    beforeEach(() => {
        provider = new SendGridProvider();
    });

    it('should send email successfully', async () => {
        const context = {
            applicationId: 'test',
            to: ['test@example.com'],
            subject: 'Test Subject',
            body: 'Test Body',
            channels: ['email'] as const,
        };

        const results = await provider.send(context);

        expect(results).toHaveLength(1);
        expect(results[0].success).toBe(true);
        expect(results[0].channel).toBe('email');
    });
});
```

### Validation des configurations

```typescript
// src/config/validation.ts
import { z } from 'zod';

const TemplateConfigSchema = z.object({
    templateId: z.string().min(1),
    providerId: z.string().min(1),
    path: z.string().min(1),
    channels: z.array(z.enum(['email', 'sms', 'push', 'webhook'])),
    dataTransformFiles: z.array(z.string()).optional(),
});

export function validateTemplateConfig(config: any): TemplateConfig {
    return TemplateConfigSchema.parse(config);
}
```

## üéØ Bonnes pratiques

### 1. Gestion d'erreurs

```typescript
// Toujours wrapper les op√©rations critiques
try {
    await provider.send(context);
} catch (error) {
    contextLogger.error('Provider send failed', { error, context });
    bus.emit(EventNames.ProviderError, { providerId: provider.id, error });
    throw error; // Re-throw pour que le caller puisse r√©agir
}
```

### 2. Configuration par environnement

```typescript
// src/config/env.ts
export const envConfig = {
    development: {
        logLevel: 'debug',
        redis: { url: 'redis://localhost:6379' },
    },
    production: { logLevel: 'info', redis: { url: process.env.REDIS_URL } },
};

export const currentConfig =
    envConfig[process.env.NODE_ENV as keyof typeof envConfig];
```

### 3. Types stricts

```typescript
// Toujours typer les interfaces
interface StrictQueueMessage extends QueueMessage {
    businessData: {
        userId: string;
        email: string;
        // ... autres champs requis
    };
}
```

### 4. Documentation des √©v√©nements

```typescript
// Documenter tous les √©v√©nements personnalis√©s
/**
 * √âmis quand un template est ex√©cut√© avec succ√®s
 * @event TemplateAfterExecute
 * @type {object}
 * @property {string} templateId - ID du template
 * @property {object} result - R√©sultat de l'ex√©cution
 */
bus.emit(EventNames.TemplateAfterExecute, { templateId, result });
```

Cette architecture modulaire permet d'√©tendre facilement le syst√®me selon les besoins tout en maintenant une s√©paration claire des responsabilit√©s et une observabilit√© compl√®te.
